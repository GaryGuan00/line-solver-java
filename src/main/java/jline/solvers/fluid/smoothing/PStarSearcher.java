// Copyright (c) 2012-2022, Imperial College London
// All rights reserved.

package jline.solvers.fluid.smoothing;

import jline.lang.constant.GlobalConstants;
import jline.lang.constant.SolverType;
import jline.solvers.NetworkAvgTable;
import jline.util.Matrix;
import jline.lang.Network;
import jline.lang.NetworkStruct;
import jline.solvers.SolverOptions;
import jline.solvers.fluid.SolverFluid;
import jline.solvers.ssa.SolverSSA;
import org.apache.commons.math3.optim.*;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.math3.random.JDKRandomGenerator;
import org.apache.commons.math3.random.RandomGenerator;
import org.ejml.data.DMatrixSparseCSC;
import org.ejml.equation.Equation;
import org.ejml.simple.SimpleMatrix;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.lang.Double.isInfinite;

// NOTE TO USER: this class has been developed for research and experimentation purposes only.
// Currently, a user is required to manually edit the local variables contained within some of this
// class' methods to change the functionality of the search-based p-norm smoothing methodology -
// this is sufficient for research and experimentation, but not for general release. Should this
// methodology be made available as part of a JLINE release in the future, a small amount of
// refactoring will be needed to move local variables to class fields, paying due attention to
// encapsulation and the flexibility required by a typical user. This is left as the subject of
// future work, given this methodology remains in the research and experimentation phase at the
// close of this current project.

public class PStarSearcher {

  public long runTime;

  // Generates the target (accurate) queue lengths used within the CMA-ES objective function
  public Matrix generateTargetQueueLengths(Network model) {

    //// USER INPUT ////: Manually set options for SolverSSA
    int numSamplesSSA = 100000;
    int seedSSA = 50;
    int R5kSSA = 19;

    // Model solved using SolverSSA
    SolverOptions options = new SolverOptions(SolverType.SSA);
    options.samples = numSamplesSSA;
    options.seed = seedSSA;
    SolverSSA solverSSA = new SolverSSA(model, options);
    solverSSA.enableR5(R5kSSA);
    NetworkAvgTable avgTable = solverSSA.getAvgTable();
    List<Double> QueueLengths = avgTable.getQLen();

//    // Note that if SolverSSA cannot be used due to the existence of bugs, comparison queue lengths
//    // need to be manually added using e.g. SolverMVA in LINE
//    // List<Double> QueueLengths = new ArrayList<>();
//    // QueueLengths.add(0, 12.905);
//    // QueueLengths.add(1, 17.083);
//
//    // Mean Queue Length transferred to a JLineMatrix
    Matrix QNSSA = new Matrix(model.getNumberOfNodes(), model.getNumberOfClasses());
    int numRows = QNSSA.getNumRows();
    for (int row = 0; row < numRows; row++) {
      int numCols = QNSSA.getNumCols();
      for (int col = 0; col < numCols; col++) {
        QNSSA.set(row, col, QueueLengths.get((row * numCols) + col));
      }
    }

    return QNSSA;
  }

  // Runs the CMA-ES algorithm to find pStar
  public PointValuePair findPStarValues(Network model, Matrix targetQueueLengths) {

    // Construct parameters for CMA-ES Optimisation
    int numNodes = model.getNumberOfNodes();
    double[] pStarInitialSolution = new double[numNodes];
    double[] sigmaInitialValues = new double[numNodes];
    double[] pStarLowerBound = new double[numNodes];
    double[] pStarUpperValue = new double[numNodes];
    // pStar is bounded between Distribution.zeroRN and +INF
    for (int i = 0; i < numNodes; i++) {
      pStarLowerBound[i] = GlobalConstants.Zero;
      pStarUpperValue[i] = Double.POSITIVE_INFINITY;
    }

    //// USER INPUT ////: Manually set arguments for CMA-ES Optimisation
    // Some comments and usage instructions taken from:
    // https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.html

    // Maximal number of iterations for CMA-ES optimizer
    int maxIterations = 100;

    // Optimizer stops if the objective function's output (errorValue) is less than stopFitness.
    // Taking a single node, the error is the square of the difference between the steady-state mean
    // queue-length generated by Fluid versus the same generated by SSA.
    // errorValue is the sum of these squared differences across all nodes.
    double stopFitnessTol = 0.01; // e.g. 0.01 means 1% of the total jobs are allocated incorrectly
    int numJobs = (int) model.getNumberOfJobs().elementSum();
    double stopFitness = Math.pow(stopFitnessTol * numJobs, 2) * 2;

    // Chooses the covariance matrix update method for CMA-ES optimizer
    boolean isActiveCMA = true;

    // Number of initial iterations where the covariance matrix remains diagonal
    int diagonalOnly = 0;

    // Random Generator - configurable to other Apache Commons RNGs if desired
    RandomGenerator rng = new JDKRandomGenerator();

    // Determines how often new random objective variables are generated in case they are out of
    // bounds
    int checkFeasibleCount = 0;

    // Determines whether statistic data is collected (or not)
    boolean generateStatistics = false;

    // Convergence checker - thresholds can be specified
    ConvergenceChecker<PointValuePair> checker = new SimpleValueChecker(0.001, 0.001);

    // Set the maximum number of evaluations of the function to be optimized
    // Can set lower using " = new MaxEval(int);"
    MaxEval maxEval = MaxEval.unlimited();

    // Set the population size. The number of offspring is the primary strategy parameter. In the
    // absence of better clues, a good default could be an integer close to 4 + 3 ln(n), where n is
    // the number of optimized parameters. Increasing the population size improves global search
    // properties at the expense of speed (which in general decreases at most linearly with
    // increasing population size).
    int defaultSize = (int) Math.round(4 + 3 * Math.log(pStarInitialSolution.length));
    CMAESOptimizer.PopulationSize populationSize = new CMAESOptimizer.PopulationSize(defaultSize);

    // Fill pStarInitialSolution[]
    // The only parameter to specify here is percentageToComputePStarUpperValue - the methodology
    // used is specified in Section 6.2 of the report accompanying this repository
    double percentageToComputePStarUpperValue = 0.999;
    Map<String, SimpleMatrix> gHatInputs = getGHatInputs(model, targetQueueLengths);
    determinePStarInitialSolution(
        pStarInitialSolution,
        model,
        gHatInputs.get("sumXQa"),
        gHatInputs.get("SQa"),
        percentageToComputePStarUpperValue);

    //

    // Determine sigmaInitialValues automatically
    // Sigma values define the initial coordinate-wise standard deviations for sampling
    // new search points around pStarInitialSolution. It is suggested to set them to the estimated
    // distance from the initial to the desired optimum. Small values induce the search to be more
    // local (and very small values are more likely to find a local optimum close to the initial
    // guess). Too small values might however lead to early termination.
    // Determine best guesses automatically
    determineSigmaInitialValues(sigmaInitialValues, pStarInitialSolution);

    // Run the CMA-ES optimisation process
    CMAESOptimizer optimizer =
        new CMAESOptimizer(
            maxIterations,
            stopFitness,
            isActiveCMA,
            diagonalOnly,
            checkFeasibleCount,
            rng,
            generateStatistics,
            checker);

    CMAESObjectiveFunction CMAESObjectiveFunction =
        new CMAESObjectiveFunction(targetQueueLengths, model, false);

    long startTime = System.nanoTime();
    PointValuePair output =
        optimizer.optimize(
            maxEval,
            new ObjectiveFunction(CMAESObjectiveFunction),
            GoalType.MINIMIZE,
            new InitialGuess(pStarInitialSolution),
            populationSize,
            new CMAESOptimizer.Sigma(sigmaInitialValues),
            new SimpleBounds(pStarLowerBound, pStarUpperValue));
    this.runTime = System.nanoTime() - startTime;

    return output;
  }

  // Returns the variables needed to compute the smoothed processor-share constraint approximation
  // for a given model. This is subsequently used to derive sensible values for
  // pStarInitialSolution[], as per Section 6.2 in the report that accompanies this repository
  private Map<String, SimpleMatrix> getGHatInputs(Network model, Matrix targetQueueLengths) {

    SolverFluid solver = new SolverFluid(model);
    NetworkStruct sn = solver.sn;
    SolverOptions options = solver.options;
    options.stiff = false;
    options.method = "matrix";

    if (options.init_sol.isEmpty()) {
      solver.initSol();
    }

    // N.B. Method assumes no prior probabilities - it will break if it encounters this

    int M = sn.nstations;
    int K = sn.nclasses;
    int totalNumPhases = (int) sn.phases.elementSum();

    Matrix S = sn.nservers.clone();
    double initialPopulation = sn.njobs.elementSum();
    int SRows = S.getNumRows();
    for (int i = 0; i < SRows; i++) {
      if (isInfinite(S.get(i, 0))) {
        S.set(i, 0, initialPopulation);
      }
    }


    DMatrixSparseCSC Qa = new DMatrixSparseCSC(1, totalNumPhases);
    int state = 0;
    for (int i = 0; i < M; i++) {
      for (int r = 0; r < K; r++) {
        int nPhases = (int) sn.phases.get(i, r);
        for (int k = 0; k < nPhases; k++) {
          Qa.set(0, state, i);
          state++;
        }
      }
    }

    DMatrixSparseCSC SQ = new DMatrixSparseCSC(totalNumPhases, totalNumPhases);
    int nextSQRow = 0;
    for (int i = 0; i < M; i++) {
      for (int r = 0; r < K; r++) {
        int nPhases = (int) sn.phases.get(i, r);
        for (int k = 0; k < nPhases; k++) {
          for (int col = 0; col < totalNumPhases; col++) {
            if (Qa.get(0, col) == i) {
              SQ.set(nextSQRow, col, 1); // Setting weights
            }
          }
          nextSQRow++;
        }
      }
    }

    DMatrixSparseCSC x = new DMatrixSparseCSC(totalNumPhases, 1);
    int end = 0;
    for (int i = 0; i < M; i++) {
      for (int r = 0; r < K; r++) {
        int numPhases = (int) sn.phases.get(i, r);
        for (int k = 0; k < numPhases; k++) {
          x.set(end, 0, targetQueueLengths.get(i, r) / numPhases);
          end++;
        }
      }
    }

    SimpleMatrix SQa = new SimpleMatrix(Qa.getNumCols(), 1);
    for (int i = 0; i < totalNumPhases; i++) {
      SQa.set(i, 0, S.get((int) Qa.get(0, i), 0));
    }

    Equation calculateSumXQa = new Equation();
    calculateSumXQa.alias(x, "x", SQ, "SQ", GlobalConstants.Zero, "distribZero");
    calculateSumXQa.process("sumXQa = distribZero + SQ * x");
    SimpleMatrix sumXQa = calculateSumXQa.lookupSimple("sumXQa");

    Map<String, SimpleMatrix> outputs = new HashMap<>();
    outputs.put("sumXQa", sumXQa);
    outputs.put("SQa", SQa);
    return outputs;
  }

  private void determinePStarInitialSolution(
      double[] pStarInitialSolution,
      Network model,
      SimpleMatrix sumXQa,
      SimpleMatrix SQa,
      double threshold) {

    SolverFluid solver = new SolverFluid(model);
    NetworkStruct sn = solver.sn;
    int M = sn.nstations;
    int K = sn.nclasses;
    Matrix nPhases = sn.phases;

    int idx = 0;
    for (int i = 0; i < M; i++) {
      double xVal = sumXQa.get(idx, 0);
      double cVal = SQa.get(idx, 0);
      // 100.0 used as an arbitrarily large number - any larger risks errors due to use as an exponent
      double maximumGHatValue = 1 / Math.pow(1 + Math.pow(xVal / cVal, 100.0), 1 / 100.0);
      double j = 0.1;
      while(true) {
        double gHatValue = 1 / Math.pow(1 + Math.pow(xVal / cVal, j), 1 / j);
        if (gHatValue >= threshold * maximumGHatValue) {
          pStarInitialSolution[i] = j / 2;
          break;
        }
        j += 0.1;
      }
      idx += K * nPhases.get(i, 0);
    }
  }

  private void determineSigmaInitialValues(double[] sigmaInitialValues, double[] pStarInitialSolution) {

    for (int i = 0; i < pStarInitialSolution.length; i++) {
      sigmaInitialValues[i] = pStarInitialSolution[i] / 2;
    }
  }
}
